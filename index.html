<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Studio Radio ‚Äî Bedrijfsstation (SkyRadio style)</title>
<style>
  :root{
    --bg:#071217; --card:#0b1b22; --accent:#1fb98a; --muted:#8fb1b0; --text:#e6f2f1;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#041014 0%, #071217 100%);color:var(--text)}
  header{padding:18px;text-align:center}
  h1{margin:6px 0;font-size:20px}
  .app{display:grid;grid-template-columns:420px 1fr;gap:14px;padding:14px}
  .card{background:var(--card);padding:12px;border-radius:10px;box-shadow:0 6px 16px rgba(0,0,0,.6)}
  .small{color:var(--muted);font-size:13px}
  label{display:block;margin-top:8px;color:var(--muted);font-size:13px}
  input[type=file], input[type=text], input[type=number], select{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid rgba(255,255,255,.06);background:transparent;color:var(--text)}
  button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:#042425;font-weight:700;cursor:pointer}
  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,.06);color:var(--text)}
  .row{display:flex;gap:8px;align-items:center}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .list{max-height:360px;overflow:auto;margin-top:10px;border-radius:8px;padding:6px;background:linear-gradient(180deg,#051416,#06171a)}
  .list-item{display:flex;justify-content:space-between;padding:8px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,.02);align-items:center}
  .fader{width:100%}
  .studio-meters{display:flex;gap:8px;align-items:flex-end;height:60px}
  .meter{width:8px;background:rgba(255,255,255,.06);border-radius:4px;position:relative;overflow:hidden}
  .meter .lvl{position:absolute;bottom:0;left:0;right:0;background:linear-gradient(180deg,#2ee6b9,#0fa37f);height:0%}
  .now{margin-top:10px;padding:10px;border-radius:8px;background:linear-gradient(90deg, rgba(24,63,52,.2), rgba(7,20,24,.2));}
  footer{padding:18px;text-align:center;color:var(--muted)}
  .search-result{display:flex;gap:8px;align-items:center}
  .thumbnail{width:72px;height:40px;object-fit:cover;border-radius:6px}
  .danger{background:#ff6b6b;color:white}
  @media(max-width:980px){.app{grid-template-columns:1fr;}}
</style>
</head>
<body>
<header>
  <h1>Studio Radio ‚Ä¢ Bedrijfszender (SkyRadio-style studio)</h1>
  <div class="small">Professionele studio UI: mix, mic talkover, jingles, schedules, YouTube-zoek, persistent opslag (IndexedDB).</div>
</header>

<div class="app">
  <!-- LINKS: Studio controls, uploads, scheduling -->
  <div>
    <div class="card">
      <strong>Studio Controls</strong>
      <div class="small">Master, main & talkover faders, mute & crossfade.</div>

      <label>Master volume</label>
      <input id="masterVol" class="fader" type="range" min="0" max="1" step="0.01" value="0.92">

      <label>Main volume</label>
      <input id="mainVol" class="fader" type="range" min="0" max="1" step="0.01" value="1">

      <label>Talkover (microfoon) volume</label>
      <input id="micVol" class="fader" type="range" min="0" max="1" step="0.01" value="0.9">

      <div style="margin-top:10px" class="row">
        <button id="startBtn">‚ñ∂ Start Studio</button>
        <button id="stopBtn" class="btn-ghost">‚èπ Stop</button>
        <button id="snapBtn" class="btn-ghost">üéß Cue</button>
      </div>

      <label style="margin-top:12px">Mic talkover</label>
      <div class="row">
        <button id="micOnBtn" class="btn-ghost">üéô Mic On</button>
        <button id="micOffBtn" class="btn-ghost">üéô Mic Off</button>
      </div>

      <div style="margin-top:12px">
        <div class="small">VU-meters</div>
        <div class="studio-meters">
          <div style="width:30%" >
            <div class="small">Main</div>
            <div class="meter" id="meterMain"><div class="lvl" style="height:0%"></div></div>
          </div>
          <div style="width:30%">
            <div class="small">Mic</div>
            <div class="meter" id="meterMic"><div class="lvl" style="height:0%"></div></div>
          </div>
          <div style="width:30%">
            <div class="small">Ads/Jingle</div>
            <div class="meter" id="meterAd"><div class="lvl" style="height:0%"></div></div>
          </div>
        </div>
      </div>

      <div class="now" id="nowPlaying">Now playing: ‚Äî</div>
    </div>

    <div style="margin-top:12px" class="card">
      <strong>Uploads & Jingles</strong>
      <div class="small">Upload tracks, jingles of reclames. Bestanden worden opgeslagen lokaal.</div>

      <label>Upload tracks (muziek)</label>
      <input id="fileMusic" type="file" accept="audio/*" multiple>

      <label>Upload jingles (voice overs)</label>
      <input id="fileJingle" type="file" accept="audio/*" multiple>

      <label>Upload reclames</label>
      <input id="fileAd" type="file" accept="audio/*" multiple>

      <div style="margin-top:12px" class="row">
        <button id="saveBtn" class="btn-ghost">üíæ Save to DB</button>
        <button id="exportBtn" class="btn-ghost">‚¨á Export config</button>
      </div>
    </div>

    <div style="margin-top:12px" class="card">
      <strong>Scheduler / Blocks</strong>
      <div class="small">Automatische reclameblokken en programmablokken (op tijd of interval).</div>

      <label>Reclameblok interval (minuten)</label>
      <input id="adInterval" type="number" min="1" value="30">

      <label>Aantal reclames per blok</label>
      <input id="adsPerBlock" type="number" min="1" value="1">

      <div style="margin-top:8px" class="row">
        <button id="startScheduler" class="btn-ghost">Start scheduler</button>
        <button id="stopScheduler" class="btn-ghost">Stop scheduler</button>
        <button id="forceAd" class="">Play ad block now</button>
      </div>

      <div class="small" style="margin-top:8px">Planned blocks</div>
      <div id="plannedBlocks" class="list"></div>
    </div>
  </div>

  <!-- RECHTS: Playlist, Youtube search, queue -->
  <div>
    <div class="card">
      <strong>Playlist & Queue</strong>
      <div class="small">Sleep items in de lijst om volgorde te veranderen. Klik om te spelen/verwijderen.</div>

      <div style="margin-top:8px;display:flex;gap:8px">
        <input id="searchTerm" type="text" placeholder="Zoek op titel of YouTube (API key nodig)"/>
        <button id="searchBtn" class="btn-ghost">üîé Zoek</button>
      </div>

      <div style="margin-top:8px" class="row controls">
        <button id="btnPrev" class="btn-ghost">‚èÆ Vorige</button>
        <button id="btnPlay" class="">‚ñ∂ Play</button>
        <button id="btnNext" class="btn-ghost">‚è≠ Volgende</button>
        <button id="btnStop" class="btn-ghost">‚èπ Stop</button>
      </div>

      <h4 style="margin-top:10px">Zoekresultaten (YouTube)</h4>
      <div id="searchResults" class="list"></div>

      <h4 style="margin-top:10px">Queue / Playlist</h4>
      <div id="playlist" class="list"></div>

      <h4 style="margin-top:10px">History</h4>
      <div id="history" class="list" style="max-height:120px"></div>
    </div>

    <div style="margin-top:12px" class="card">
      <strong>Studio Dashboard</strong>
      <div class="small">Snel info en logs</div>
      <div id="studioLogs" class="list" style="max-height:220px"></div>
    </div>
  </div>
</div>

<footer>
  <small>Opmerkingen: Deze studio werkt lokaal in de browser. Voor publieke streaming heb je een streamingserver nodig (Icecast/Shoutcast of een hostingdienst).</small>
</footer>

<script>
/* ============================
   Studio Radio ‚Äî single page
   Features:
   - IndexedDB storage for media
   - WebAudio mixing (main + mic talkover + ads)
   - YouTube search (requires API key) and embed playback option
   - Scheduler for ad blocks or timed program blocks
   - Crossfade, faders, VU meters, queue, history
   - Export/import config (media names only)
   ============================ */

/* ========== CONFIG ========== */
const YT_API_KEY = "YOUR_API_KEY_HERE"; // zet hier je YouTube Data API v3 key
const MAX_SEARCH=6;

/* ========== IndexedDB helpers ========== */
function openDB(name='StudioDB',version=1){
  return new Promise((res,rej)=>{
    const r = indexedDB.open(name,version);
    r.onupgradeneeded = ()=>{
      const db = r.result;
      if(!db.objectStoreNames.contains('music')) db.createObjectStore('music');
      if(!db.objectStoreNames.contains('ads')) db.createObjectStore('ads');
      if(!db.objectStoreNames.contains('jingles')) db.createObjectStore('jingles');
      if(!db.objectStoreNames.contains('meta')) db.createObjectStore('meta');
    };
    r.onsuccess = ()=>res(r.result);
    r.onerror = ()=>rej(r.error);
  });
}
async function putFile(store,key,file){
  const db = await openDB();
  return new Promise(resolve=>{
    const tx = db.transaction(store,'readwrite');
    tx.objectStore(store).put(file,key);
    tx.oncomplete = ()=>resolve();
  });
}
async function getAll(store){
  const db = await openDB();
  return new Promise(resolve=>{
    const tx = db.transaction(store,'readonly');
    const out=[];
    const cur = tx.objectStore(store).openCursor();
    cur.onsuccess = e=>{
      const c = e.target.result;
      if(c){ out.push({name:c.key,blob:c.value}); c.continue(); }
      else resolve(out);
    };
  });
}
async function deleteKey(store,key){
  const db = await openDB();
  return new Promise(resolve=>{
    const tx = db.transaction(store,'readwrite');
    tx.objectStore(store).delete(key);
    tx.oncomplete = ()=>resolve();
  });
}

/* ========== UI elements ========== */
const fileMusic = document.getElementById('fileMusic');
const fileAd = document.getElementById('fileAd');
const fileJingle = document.getElementById('fileJingle');
const playlistEl = document.getElementById('playlist');
const searchBtn = document.getElementById('searchBtn');
const searchTerm = document.getElementById('searchTerm');
const searchResults = document.getElementById('searchResults');
const nowPlayingEl = document.getElementById('nowPlaying');
const studioLogs = document.getElementById('studioLogs');
const plannedBlocksEl = document.getElementById('plannedBlocks');
const plannedBlocks = []; // timestamps
const historyEl = document.getElementById('history');

function logStudio(msg){
  const t = new Date().toLocaleTimeString();
  studioLogs.innerHTML = `<div>[${t}] ${msg}</div>` + studioLogs.innerHTML;
}

/* ========== State ========== */
let music = []; // {name,url,key}
let ads = [];
let jingles = [];
let queue = []; // {type:'local'|'youtube', name, url?, videoId?}
let history = [];
let currentIndex = -1;
let audioCtx, masterGain, mainGain, micGain, adGain;
let mainAudio = new Audio(); mainAudio.crossOrigin="anonymous";
let adAudio = new Audio(); adAudio.crossOrigin="anonymous";
let micStreamNode = null, mediaStream=null;
let metersInterval = null;
let schedulerInterval = null;

/* ========== Audio graph ========== */
function setupAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain(); masterGain.gain.value = Number(document.getElementById('masterVol').value);
  mainGain = audioCtx.createGain(); mainGain.gain.value = Number(document.getElementById('mainVol').value);
  micGain = audioCtx.createGain(); micGain.gain.value = Number(document.getElementById('micVol').value);
  adGain = audioCtx.createGain(); adGain.gain.value = 1.0;

  const mainSrc = audioCtx.createMediaElementSource(mainAudio);
  const adSrc = audioCtx.createMediaElementSource(adAudio);

  mainSrc.connect(mainGain);
  adSrc.connect(adGain);

  // mic node will be connected when mic is on
  mainGain.connect(masterGain);
  adGain.connect(masterGain);
  micGain.connect(masterGain);

  masterGain.connect(audioCtx.destination);

  // meter monitoring
  startMeters();
  logStudio('AudioContext gestart');
}

function setMasterVolume(v){ if(masterGain) masterGain.gain.value = v; }
function setMainVolume(v){ if(mainGain) mainGain.gain.value = v; }
function setMicVolume(v){ if(micGain) micGain.gain.value = v; }

/* ========== Meters (simple) ========== */
function meterUpdate(elId, level){
  const el = document.querySelector(elId + ' .lvl');
  if(el) el.style.height = `${Math.min(100, Math.round(level*100))}%`;
}
function startMeters(){
  if(metersInterval) clearInterval(metersInterval);
  // simple fake meters using volume properties and random small values; real RMS analysis can be added later
  metersInterval = setInterval(()=>{
    // approximate main level while playing
    let mainLevel = mainAudio && !mainAudio.paused ? Math.random()*0.5 + 0.2 : 0.02;
    let micLevel = mediaStream ? Math.random()*0.6 + 0.25 : 0.02;
    let adLevel = adAudio && !adAudio.paused ? Math.random()*0.45 + 0.15 : 0.02;
    meterUpdate('#meterMain', mainLevel);
    meterUpdate('#meterMic', micLevel);
    meterUpdate('#meterAd', adLevel);
  },120);
}

/* ========== Load saved media from DB ========== */
async function loadAll(){
  const m = await getAll('music');
  const a = await getAll('ads');
  const j = await getAll('jingles');
  music = m.map(x=>({name:x.name,url:URL.createObjectURL(x.blob),key:x.name}));
  ads = a.map(x=>({name:x.name,url:URL.createObjectURL(x.blob),key:x.name}));
  jingles = j.map(x=>({name:x.name,url:URL.createObjectURL(x.blob),key:x.name}));
  renderLists();
  logStudio('Media geladen uit database');
}

/* ========== Render lists ========== */
function renderLists(){
  playlistEl.innerHTML = queue.map((q,i)=>`<div class="list-item">
    <div style="flex:1">
      <div><strong>${q.name}</strong></div>
      <div class="small">${q.type}</div>
    </div>
    <div style="display:flex;gap:6px">
      <button onclick="playQueueIndex(${i})">‚ñ∂</button>
      <button onclick="removeQueueItem(${i})" class="btn-ghost">‚úñ</button>
    </div>
  </div>`).join('');

  document.getElementById('plannedBlocks').innerHTML = plannedBlocks.map(ts=>`<div class="list-item">
    <div style="flex:1">${new Date(ts).toLocaleString()}</div><div><button onclick="removePlanned(${ts})">X</button></div>
  </div>`).join('');

  document.getElementById('adCount')?.innerText = ads.length || 0;
  document.getElementById('jingleCount')?.innerText = jingles.length || 0;

  // music / ad / jingle lists
  const musicList = document.getElementById('musicList');
  if(musicList) musicList.innerHTML = music.map((m,i)=>`<div class="list-item"><div style="flex:1">${m.name}</div>
    <div style="display:flex;gap:6px"><button onclick="playLocal(${i})">‚ñ∂</button></div></div>`).join('');
  const adList = document.getElementById('adList');
  if(adList) adList.innerHTML = ads.map((a,i)=>`<div class="list-item"><div style="flex:1">${a.name}</div>
    <div style="display:flex;gap:6px"><button onclick="removeAd(${i})">‚úñ</button></div></div>`).join('');
  const jList = document.getElementById('jingleList');
  if(jList) jList.innerHTML = jingles.map((j,i)=>`<div class="list-item"><div style="flex:1">${j.name}</div><div><button onclick="removeJingle(${i})">‚úñ</button></div></div>`).join('');
}

/* ========== File upload handlers ========== */
fileMusic.addEventListener('change', async (e)=>{
  for(const f of e.target.files){
    await putFile('music', f.name, f);
    music.push({name:f.name, url:URL.createObjectURL(f), key:f.name});
  }
  renderLists();
  logStudio('Tracks ge√ºpload');
});
fileAd.addEventListener('change', async (e)=>{
  for(const f of e.target.files){
    await putFile('ads', f.name, f);
    ads.push({name:f.name, url:URL.createObjectURL(f), key:f.name});
  }
  renderLists();
  logStudio('Reclames ge√ºpload');
});
fileJingle.addEventListener('change', async (e)=>{
  for(const f of e.target.files){
    await putFile('jingles', f.name, f);
    jingles.push({name:f.name, url:URL.createObjectURL(f), key:f.name});
  }
  renderLists();
  logStudio('Jingles ge√ºpload');
});

/* ========== Queue / playback control ========== */
function addToQueue(item){ queue.push(item); renderLists(); logStudio('Toegevoegd aan queue: '+item.name); }
function removeQueueItem(i){ queue.splice(i,1); renderLists(); }

async function playQueueIndex(i){
  if(i<0 || i>=queue.length) return;
  currentIndex = i;
  const item = queue[i];
  await playItem(item);
}

async function playItem(item){
  setupAudio();
  if(item.type==='local'){
    // local file url in item.url
    adAudio.pause(); mainAudio.pause();
    mainAudio.src = item.url;
    mainAudio.play();
    nowPlayingEl.innerText = 'Now playing: ' + item.name;
    history.unshift({name:item.name, ts:Date.now()});
    renderHistory();
    logStudio('Speelt: '+item.name);
    // when main ends -> next or ad
    mainAudio.onended = async ()=>{
      // randomly insert jingle 20% chance
      if(jingles.length && Math.random()<0.2){
        await playJingleThenNext();
      } else {
        nextInQueue();
      }
    };
  } else if(item.type==='youtube'){
    // open embedded player in a new window/tab or play in iframe? to keep simple, open a small popup
    const url = 'https://www.youtube.com/embed/'+item.videoId+'?autoplay=1';
    window.open(url, '_blank', 'width=700,height=460');
    nowPlayingEl.innerText = 'Now playing (YouTube): ' + item.name;
    history.unshift({name:item.name, ts:Date.now()});
    renderHistory();
    logStudio('YouTube geopend: '+item.name);
    // can't reliably detect end from popup; just proceed after estimated length if provided (not available here)
    setTimeout(nextInQueue, 1000*60*3); // fallback next after 3 min
  }
}

function nextInQueue(){
  if(queue.length===0) return;
  currentIndex = (currentIndex + 1) % queue.length;
  playQueueIndex(currentIndex);
}
function prevInQueue(){
  if(queue.length===0) return;
  currentIndex = (currentIndex - 1 + queue.length) % queue.length;
  playQueueIndex(currentIndex);
}

/* jingles/ad helpers */
async function playJingleThenNext(){
  if(jingles.length===0){ nextInQueue(); return; }
  const j = jingles[Math.floor(Math.random()*jingles.length)];
  adAudio.pause(); mainAudio.pause();
  adAudio.src = j.url;
  adAudio.play();
  nowPlayingEl.innerText = 'Jingle: ' + j.name;
  history.unshift({name:'Jingle: '+j.name, ts:Date.now()});
  renderHistory();
  logStudio('Jingle speelt: '+j.name);
  await waitUntilEnd(adAudio);
  nextInQueue();
}

async function playAdBlock(){
  if(ads.length===0){ logStudio('Geen reclames beschikbaar'); nextInQueue(); return; }
  const count = Number(document.getElementById('adsPerBlock').value || 1);
  for(let i=0;i<count;i++){
    const a = ads[Math.floor(Math.random()*ads.length)];
    adAudio.src = a.url;
    mainAudio.pause();
    adAudio.play();
    nowPlayingEl.innerText = 'Reclame: ' + a.name;
    history.unshift({name:'Reclame: '+a.name, ts:Date.now()});
    renderHistory();
    logStudio('Reclame speelt: '+a.name);
    await waitUntilEnd(adAudio);
  }
  logStudio('Einde reclameblok');
  nextInQueue();
}

/* ========== Utility to wait until audio element ends ========== */
function waitUntilEnd(el){
  return new Promise(res=>{
    const handler = ()=>{ el.removeEventListener('ended',handler); res(); };
    el.addEventListener('ended', handler);
  });
}

/* ========== YouTube search ========== */
searchBtn.addEventListener('click', async ()=>{
  const q = searchTerm.value.trim();
  if(!q) return alert('Voer zoekterm in');
  if(!YT_API_KEY || YT_API_KEY==='YOUR_API_KEY_HERE') return alert('Vul je YouTube API key in de scriptconfig (YT_API_KEY).');
  searchResults.innerHTML = 'Zoekt...';
  try{
    const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=${MAX_SEARCH}&q=${encodeURIComponent(q)}&key=${YT_API_KEY}`;
    const r = await fetch(url);
    const js = await r.json();
    if(js.error){ searchResults.innerHTML = 'Fout bij zoeken: '+js.error.message; return; }
    searchResults.innerHTML = js.items.map(it=>{
      const title = it.snippet.title;
      const thumb = it.snippet.thumbnails && it.snippet.thumbnails.default ? it.snippet.thumbnails.default.url : '';
      const vid = it.id.videoId;
      return `<div class="list-item search-result">
        <img class="thumbnail" src="${thumb}" alt="">
        <div style="flex:1"><strong>${title}</strong><div class="small">YouTube</div></div>
        <div style="display:flex;gap:6px">
          <button onclick="addYoutubeToQueue('${vid}','${escapeToJs(title)}')">‚ûï Voeg toe</button>
          <button onclick="openYoutube('${vid}')">‚ñ∂ Open</button>
        </div>
      </div>`;
    }).join('');
  }catch(e){ searchResults.innerHTML = 'Zoekfout'; console.error(e); }
});

function escapeToJs(s){ return s.replace(/'/g,"&#39;").replace(/"/g,"&quot;"); }
window.addYoutubeToQueue = function(videoId,title){
  addToQueue({type:'youtube',name:title,videoId:videoId});
};
window.openYoutube = function(videoId){
  const url = 'https://www.youtube.com/watch?v='+videoId;
  window.open(url,'_blank');
};

/* ========== Mic/talkover (getUserMedia) ========== */
document.getElementById('micOnBtn').addEventListener('click', async ()=>{
  try{
    if(!audioCtx) setupAudio();
    mediaStream = await navigator.mediaDevices.getUserMedia({audio:true});
    micStreamNode = audioCtx.createMediaStreamSource(mediaStream);
    micStreamNode.connect(micGain);
    micGain.gain.value = Number(document.getElementById('micVol').value || 0.9);
    logStudio('Microfoon ingeschakeld');
  }catch(e){ alert('Kon mic niet openen: '+e.message); }
});
document.getElementById('micOffBtn').addEventListener('click', ()=>{
  if(mediaStream){
    mediaStream.getTracks().forEach(t=>t.stop());
    micStreamNode && micStreamNode.disconnect();
    mediaStream = null;
    logStudio('Microfoon uit');
  }
});

/* ========== Buttons / shortcuts ========== */
document.getElementById('startBtn').addEventListener('click', ()=>{
  setupAudio();
  if(queue.length===0 && music.length>0){
    // if queue empty, auto fill queue from music
    music.forEach(m=>queue.push({type:'local',name:m.name,url:m.url}));
    renderLists();
  }
  if(!audioCtx) setupAudio();
  if(queue.length>0){ playQueueIndex(0); logStudio('Studio gestart'); }
});
document.getElementById('stopBtn').addEventListener('click', ()=>{ mainAudio.pause(); adAudio.pause(); logStudio('Stop'); nowPlayingEl.innerText='Now playing: ‚Äî'; });
document.getElementById('btnPlay').addEventListener('click', ()=>{ if(currentIndex<0 && queue.length>0) playQueueIndex(0); else if(!mainAudio.paused) mainAudio.play(); else mainAudio.play(); });
document.getElementById('btnNext').addEventListener('click', ()=>nextInQueue());
document.getElementById('btnPrev').addEventListener('click', ()=>prevInQueue());
document.getElementById('btnStop').addEventListener('click', ()=>{ mainAudio.pause(); adAudio.pause(); });

document.getElementById('masterVol').addEventListener('input', e=>setMasterVolume(e.target.value));
document.getElementById('mainVol').addEventListener('input', e=>setMainVolume(e.target.value));
document.getElementById('micVol').addEventListener('input', e=>setMicVolume(e.target.value));

document.getElementById('saveBtn').addEventListener('click', async ()=>{
  logStudio('Opslaan gevraagd ‚Äî media is al persistent in DB bij upload. Gebruik Export voor config.');
  alert('Media wordt automatisch opgeslagen in DB bij upload. Gebruik Export om config te downloaden (namen only).');
});
document.getElementById('exportBtn').addEventListener('click', ()=>{
  const cfg = {music:music.map(m=>m.name), ads:ads.map(a=>a.name), jingles:jingles.map(j=>j.name), queue:queue.map(q=>q.name)};
  const blob = new Blob([JSON.stringify(cfg,null,2)],{type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'studio-config.json';
  a.click();
});

/* ========== Scheduler ========== */
document.getElementById('startScheduler').addEventListener('click', ()=>{
  const mins = Number(document.getElementById('adInterval').value || 30);
  if(schedulerInterval) clearInterval(schedulerInterval);
  schedulerInterval = setInterval(()=>{ plannedBlocks.push(Date.now()); renderLists(); logStudio('Automatisch reclameblok gepland'); }, mins*60*1000);
  logStudio('Scheduler gestart: elk '+mins+' minuten');
});
document.getElementById('stopScheduler').addEventListener('click', ()=>{
  if(schedulerInterval) clearInterval(schedulerInterval); schedulerInterval=null; logStudio('Scheduler gestopt');
});
document.getElementById('forceAd').addEventListener('click', ()=>playAdBlock());

function removePlanned(ts){ const i = plannedBlocks.indexOf(ts); if(i>=0){ plannedBlocks.splice(i,1); renderLists(); } }

/* ========== Helpers: play local directly, remove media ========== */
function playLocal(i){ addToQueue({type:'local',name:music[i].name,url:music[i].url}); playQueueIndex(queue.length-1); }

async function removeAd(i){
  await deleteKey('ads', ads[i].key);
  ads.splice(i,1); renderLists();
}
async function removeJingle(i){
  await deleteKey('jingles', jingles[i].key);
  jingles.splice(i,1); renderLists();
}

/* ========== History ========== */
function renderHistory(){ historyEl.innerHTML = history.slice(0,30).map(h=>`<div class="list-item"><div style="flex:1">${h.name}<div class="small">${new Date(h.ts).toLocaleString()}</div></div></div>`).join(''); }

/* ========== Utility functions ========== */
function addToQueueAndMaybePlay(item){
  addToQueue(item);
  if(currentIndex<0) playQueueIndex(0);
}
function addToQueue(item){ queue.push(item); renderLists(); }
function removeQueue(i){ queue.splice(i,1); renderLists(); }
window.removeQueueItem = removeQueueItem;
function removeQueueItem(i){ queue.splice(i,1); renderLists(); }
window.playQueueIndex = playQueueIndex;

/* ========== small helpers ========== */
function wait(ms){ return new Promise(res=>setTimeout(res,ms)); }

/* ========== Startup: load DB and attach some helpers ========== */
(async function(){
  await loadAll();
  setupAudio();
  renderLists();
  logStudio('Studio ready');
  // quick-hotkeys
  window.addEventListener('keydown',(e)=>{
    if(e.key===' '){ e.preventDefault(); if(mainAudio.paused) mainAudio.play(); else mainAudio.pause(); }
    if(e.key==='n') nextInQueue();
    if(e.key==='p') prevInQueue();
  });
})();

/* ========== Notes for you ==========
 - Vul YT_API_KEY in de script header als je YouTube-zoek wilt gebruiken.
 - Om publiek te streamen: zet Icecast/SHOUTcast op en stuur audio daarheen (server-side). Ik kan je een Node.js voorbeeld geven.
 - Deze app bewaart ge√ºploade audio lokaal in de browser (IndexedDB) ‚Äî geen server nodig.
 - Als je wilt, voeg ik een admin-login, multi-user vs live broadcast, of server-side scheduler toe.
==================================== */

</script>
</body>
</html>

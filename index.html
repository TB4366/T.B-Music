// server.js
const express = require('express');
const fetch = require('node-fetch');
const sqlite3 = require('sqlite3').verbose();
const bodyParser = require('body-parser');
const path = require('path');

const app = express();
app.use(bodyParser.json());
app.use(express.static(path.join(__dirname, 'public'))); // serve index.html uit /public

// DB setup
const db = new sqlite3.Database('./account_links.db');
db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS account_links (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    google_sub TEXT UNIQUE,
    google_email TEXT,
    fb_id TEXT UNIQUE,
    fb_email TEXT,
    linked_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);
});

// Helper: verifieer Google id_token (returns payload or throws)
async function verifyGoogleIdToken(id_token) {
  // Gebruik tokeninfo endpoint
  const res = await fetch(`https://oauth2.googleapis.com/tokeninfo?id_token=${encodeURIComponent(id_token)}`);
  if (!res.ok) throw new Error('Google token niet geldig');
  const payload = await res.json();
  // payload.sub is de Google unieke user id (UID)
  return payload;
}

// Helper: verifieer FB access token (returns object with id,email)
async function verifyFacebookToken(access_token) {
  const res = await fetch(`https://graph.facebook.com/me?fields=id,email,name&access_token=${encodeURIComponent(access_token)}`);
  if (!res.ok) {
    const err = await res.text();
    throw new Error('Facebook token niet geldig: ' + err);
  }
  const payload = await res.json();
  return payload;
}

// Endpoint om tokens te ontvangen en koppeling te maken
app.post('/link', async (req, res) => {
  try {
    const { google_id_token, fb_access_token } = req.body;
    if (!google_id_token || !fb_access_token) return res.status(400).json({ error: 'Ontbrekende tokens' });

    const g = await verifyGoogleIdToken(google_id_token);
    const f = await verifyFacebookToken(fb_access_token);

    const googleSub = g.sub;
    const googleEmail = g.email || null;
    const fbId = f.id;
    const fbEmail = f.email || null;

    // Hier kun je aanvullende checks doen: bijv. of user eigenaar is, dubbele koppelingen, etc.

    // Sla mapping op (insert or update)
    db.serialize(() => {
      const stmt = db.prepare(`
        INSERT INTO account_links (google_sub, google_email, fb_id, fb_email)
        VALUES (?, ?, ?, ?)
        ON CONFLICT(google_sub) DO UPDATE SET fb_id = excluded.fb_id, fb_email = excluded.fb_email
      `);
      stmt.run(googleSub, googleEmail, fbId, fbEmail, function(err) {
        if (err) {
          // Mogelijke sqlite versie zonder upsert: fallback op update/insert
          return res.status(500).json({ error: 'DB fout: ' + err.message });
        }
        res.json({ message: 'Accounts gekoppeld', google_sub: googleSub, fb_id: fbId });
      });
      stmt.finalize();
    });

  } catch (err) {
    console.error(err);
    res.status(400).json({ error: err.message });
  }
});

// Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server draaiend op http://localhost:${PORT}`);
});

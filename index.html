<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Mijn Radio Studio — Webapp</title>
<style>
  :root{--bg:#0f1720;--panel:#111827;--muted:#9ca3af;--accent:#06b6d4}
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#071021 0%, #08121a 100%);color:#e6eef6}
  header{padding:18px 24px;display:flex;align-items:center;gap:16px}
  header h1{margin:0;font-size:18px}
  .container{display:grid;grid-template-columns:360px 1fr;gap:18px;padding:18px}
  .panel{background:var(--panel);border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,.6)}
  .small{font-size:13px;color:var(--muted)}
  button{background:var(--accent);border:none;padding:10px 12px;border-radius:8px;color:#022;cursor:pointer}
  button.secondary{background:#1f2937;color:var(--muted)}
  input,select,textarea{width:100%;padding:8px;border-radius:6px;border:1px solid #253042;background:#0b1220;color:#e6eef6}
  .playlist-item{padding:8px;border-radius:6px;background:linear-gradient(90deg,#071827, #081827);display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .controls{display:flex;gap:8px;align-items:center}
  video{width:100%;border-radius:8px;background:black}
  .nowplaying{font-weight:600;font-size:16px}
  footer{padding:12px 18px;color:var(--muted);font-size:13px}
  .kbd{background:#0f1720;padding:4px 6px;border-radius:4px;border:1px solid #1f2a37}
  .row{display:flex;gap:8px}
  label{font-size:13px;color:var(--muted);}
</style>
</head>
<body>
<header>
  <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='36' height='36'><rect rx='6' width='36' height='36' fill='%2306b6d4'/><text x='50%' y='54%' font-size='18' font-family='Arial' text-anchor='middle' fill='%23000'>R</text></svg>" alt="logo" style="width:42px;height:42px;border-radius:8px">
  <div>
    <h1>Mijn Radio Studio — Webapp</h1>
    <div class="small">Chromebook friendly — lokaal draaien. Klaar voor streaming met een gateway/server (instructies onderaan).</div>
  </div>
</header>

<div class="container">
  <!-- LEFT: Controls & Playlist -->
  <div>
    <div class="panel">
      <h3>Studio Controls</h3>
      <div class="small">Microfoon & camera, mix en uitzending-ready.</div>
      <div style="margin-top:12px">
        <label>Camera</label>
        <video id="videoPreview" autoplay playsinline muted></video>
        <div style="margin-top:8px;display:flex;gap:8px">
          <button id="startCamBtn">Start Camera</button>
          <button id="stopCamBtn" class="secondary">Stop Camera</button>
        </div>
      </div>

      <hr style="margin:12px 0;border:none;border-top:1px solid #16202b">

      <label>Microfoon</label>
      <div class="row" style="margin-top:8px">
        <button id="toggleMicBtn">Microfoon AAN</button>
        <button id="muteMicBtn" class="secondary">Mute</button>
      </div>
      <div class="small" style="margin-top:8px">Mic status: <span id="micStatus">uit</span></div>

      <hr style="margin:12px 0;border:none;border-top:1px solid #16202b">

      <h4>Output / Broadcast</h4>
      <div class="small">Kies één van de volgende opties om je gemixte stream lokaal te bewaren of naar een server te sturen.</div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="startRecordBtn">Start Opname (WebM)</button>
        <button id="stopRecordBtn" class="secondary">Stop & Download</button>
      </div>
      <div style="margin-top:8px">
        <label>WebRTC / Server URL (optioneel)</label>
        <input id="serverUrl" placeholder="wss://mijn-server.example/ws (optioneel)"> 
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="startLiveBtn">Start Live (WebRTC)</button>
          <button id="stopLiveBtn" class="secondary">Stop Live</button>
        </div>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Auto-Duck & Mixing</h3>
      <label>Autoduck (music gain when mic active)</label>
      <div style="display:flex;gap:8px;margin-top:8px">
        <input id="duckAmount" type="range" min="0" max="1" step="0.05" value="0.25">
        <div class="small" id="duckVal">0.25</div>
      </div>
      <div style="margin-top:8px">
        <label>Master volume</label>
        <input id="masterVol" type="range" min="0" max="1" step="0.01" value="0.9">
      </div>
      <div style="margin-top:8px" class="small">Tip: zet autoduck laag (0.2-0.4) voor gespreksoulouding tijdens jingles of talkover.</div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Uurklok + Scheduler (eenvoudig)</h3>
      <div class="small">Maak blokken die op bepaalde tijden nummers of playlists starten. (Eenvoudige lokale scheduler op browser-tijd.)</div>
      <div style="margin-top:8px">
        <label>Voeg blok toe (HH:MM - playlist start)</label>
        <div style="display:flex;gap:8px;margin-top:6px">
          <input id="schedTime" placeholder="09:00">
          <select id="schedPlaylist"></select>
          <button id="addSchedBtn">Voeg toe</button>
        </div>
        <div id="schedList" style="margin-top:8px"></div>
      </div>
    </div>
  </div>

  <!-- RIGHT: Player, Playlist, Nowplaying -->
  <div>
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="nowplaying">Now playing:</div>
          <div id="nowPlayingText" style="font-size:15px;color:var(--muted);margin-top:6px">— niets</div>
        </div>
        <div>
          <div class="small">Master metering</div>
          <div id="meter" style="width:180px;height:10px;background:#071827;border-radius:6px;overflow:hidden;margin-top:8px">
            <div id="meterBar" style="height:100%;width:0%;background:linear-gradient(90deg,#06b6d4,#0ea5a3)"></div>
          </div>
        </div>
      </div>

      <hr style="margin:12px 0;border:none;border-top:1px solid #16202b">

      <audio id="player" controls style="width:100%;"></audio>

      <div style="display:flex;gap:8px;margin-top:10px">
        <input type="file" id="filePicker" accept="audio/*" multiple>
        <button id="addFromFilesBtn" class="secondary">Voeg toe</button>
        <button id="clearPlaylistBtn" class="secondary">Clear</button>
      </div>

      <h4 style="margin-top:14px">Playlist</h4>
      <div id="playlist" style="max-height:360px;overflow:auto;margin-top:6px"></div>

    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Templates & Jingles</h3>
      <div class="small">Je kunt hier pre-recorded jingles toevoegen en 'cues' maken om snel te spelen.</div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <input type="file" id="jinglePicker" accept="audio/*">
        <button id="addJingleBtn">Voeg jingle</button>
      </div>
      <div id="jinglesList" style="margin-top:8px"></div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Tips voor uitzend-klaar</h3>
      <ol style="color:var(--muted);font-size:14px">
        <li>Zorg voor licenties voor commerciële muziek (Buma/Sena of rechtenvrije muziek).</li>
        <li>Gebruik een WebRTC → RTMP gateway (Ant Media, Janus, mediasoup of een eenvoudige Node app) om browserstreams naar YouTube te sturen.</li>
        <li>Test eerst met "Unlisted" YouTube stream key en controleer audio levels.</li>
      </ol>
    </div>
  </div>
</div>

<footer>
  Deze applicatie draait volledig in je browser en slaat playlists/schedules lokaal (LocalStorage). Voor live naar YouTube/website streamen heb je een server-gateway nodig — instructies staan in het bestand.
</footer>

<script>
// -----------------------------
// Simple Radio Studio Webapp
// - Playlist via local files
// - WebAudio mixing (music + mic)
// - Camera preview
// - Local recording (MediaRecorder)
// - Basic scheduler (local time)
// -----------------------------

// State
let audioContext, masterGain, musicGain, micGain, destinationNode, micSourceNode;
let playlist = []; // {id, name, blob, url, duration}
let jingles = [];
let currentIndex = -1;
let isMicOn = false;
let micStream = null;
let camStream = null;
let recorder = null;
let recordedChunks = [];
let liveSocket = null;
let scheduler = [];

// UI
const videoPreview = document.getElementById('videoPreview');
const startCamBtn = document.getElementById('startCamBtn');
const stopCamBtn = document.getElementById('stopCamBtn');
const toggleMicBtn = document.getElementById('toggleMicBtn');
const muteMicBtn = document.getElementById('muteMicBtn');
const micStatus = document.getElementById('micStatus');
const filePicker = document.getElementById('filePicker');
const addFromFilesBtn = document.getElementById('addFromFilesBtn');
const playlistDiv = document.getElementById('playlist');
const player = document.getElementById('player');
const nowPlayingText = document.getElementById('nowPlayingText');
const meterBar = document.getElementById('meterBar');
const startRecordBtn = document.getElementById('startRecordBtn');
const stopRecordBtn = document.getElementById('stopRecordBtn');
const serverUrlInput = document.getElementById('serverUrl');
const startLiveBtn = document.getElementById('startLiveBtn');
const stopLiveBtn = document.getElementById('stopLiveBtn');
const duckAmount = document.getElementById('duckAmount');
const duckVal = document.getElementById('duckVal');
const masterVol = document.getElementById('masterVol');
const addJingleBtn = document.getElementById('addJingleBtn');
const jinglePicker = document.getElementById('jinglePicker');
const jinglesList = document.getElementById('jinglesList');
const schedPlaylist = document.getElementById('schedPlaylist');
const schedTime = document.getElementById('schedTime');
const addSchedBtn = document.getElementById('addSchedBtn');
const schedList = document.getElementById('schedList');
const clearPlaylistBtn = document.getElementById('clearPlaylistBtn');

// Init AudioContext and graph
function initAudio() {
  if (audioContext) return;
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioContext.createGain();
  musicGain = audioContext.createGain();
  micGain = audioContext.createGain();
  destinationNode = audioContext.createMediaStreamDestination();

  masterGain.gain.value = parseFloat(masterVol.value);
  musicGain.gain.value = 1.0;
  micGain.gain.value = 1.0;

  // music -> musicGain -> master
  musicGain.connect(masterGain);
  // mic -> micGain -> master
  micGain.connect(masterGain);
  // master -> destination (MediaStream)
  masterGain.connect(destinationNode);
  // and to audioContext.destination for local monitoring
  masterGain.connect(audioContext.destination);

  // meter updater
  requestAnimationFrame(updateMeter);
}

function updateMeter(){
  if (!audioContext) return requestAnimationFrame(updateMeter);
  // naive meter: use masterGain.gain and mic activity
  const val = Math.min(1, masterGain.gain.value * (1 + Math.random()*0.2));
  meterBar.style.width = (val*100) + '%';
  requestAnimationFrame(updateMeter);
}

// Add files from <input>
addFromFilesBtn.onclick = ()=> filePicker.click();
filePicker.onchange = async (e)=>{
  const files = Array.from(e.target.files);
  for (const f of files) await addAudioFile(f);
  filePicker.value = '';
};

async function addAudioFile(file){
  const url = URL.createObjectURL(file);
  const id = 't_' + Date.now() + Math.random().toString(36).slice(2,8);
  const meta = {id, name: file.name, blob: file, url, duration: 0};
  playlist.push(meta);
  renderPlaylist();
  // populate scheduler playlist options
  updateSchedOptions();
}

function renderPlaylist(){
  playlistDiv.innerHTML = '';
  playlist.forEach((t,i)=>{
    const el = document.createElement('div');
    el.className = 'playlist-item';
    el.innerHTML = `<div style="flex:1"><strong>${t.name}</strong><div class=\"small\">#${i+1}</div></div>
      <div style=\"display:flex;gap:6px\"> <button data-i=\"${i}\">Play</button> <button data-rem=\"${i}\" class=\"secondary\">Remove</button></div>`;
    playlistDiv.appendChild(el);
  });
  // wire buttons
  playlistDiv.querySelectorAll('button[data-i]').forEach(b=> b.onclick = ()=> playIndex(parseInt(b.dataset.i)));
  playlistDiv.querySelectorAll('button[data-rem]').forEach(b=> b.onclick = ()=> {playlist.splice(parseInt(b.dataset.rem),1); renderPlaylist(); updateSchedOptions();});
}

function playIndex(i){
  initAudio();
  if (i<0 || i>=playlist.length) return;
  currentIndex = i;
  const item = playlist[i];
  nowPlayingText.textContent = item.name;

  // load into <audio> element then connect to audio graph
  player.src = item.url;
  player.play();
  // connect to WebAudio only after element created
  // create source and connect to musicGain
  setTimeout(()=>{
    try{
      if (player._webaudioSource) player._webaudioSource.disconnect();
    }catch(e){}
    try{
      const src = audioContext.createMediaElementSource(player);
      player._webaudioSource = src;
      src.connect(musicGain);
    }catch(e){console.warn('could not connect element source',e)}
  },200);
}

// autoplay next
player.onended = ()=>{
  const next = (currentIndex+1) % playlist.length;
  if (playlist.length>0) playIndex(next);
};

// Camera controls
startCamBtn.onclick = async ()=>{
  try{
    camStream = await navigator.mediaDevices.getUserMedia({video:{width:640}, audio:false});
    videoPreview.srcObject = camStream;
  }catch(e){alert('Camera error: '+e.message)}
}
stopCamBtn.onclick = ()=>{ if (camStream){ camStream.getTracks().forEach(t=>t.stop()); videoPreview.srcObject=null; camStream=null;} }

// Microphone controls & routing
toggleMicBtn.onclick = async ()=>{
  if (!isMicOn){
    try{
      micStream = await navigator.mediaDevices.getUserMedia({audio:true});
      initAudio();
      micSourceNode = audioContext.createMediaStreamSource(micStream);
      micSourceNode.connect(micGain);
      micStatus.textContent = 'aan';
      toggleMicBtn.textContent = 'Microfoon UIT';
      toggleMicBtn.classList.add('secondary');
      isMicOn = true;
      // apply ducking when mic active
      applyDucking();
    }catch(e){alert('Mic error: '+e.message)}
  } else {
    if (micStream){ micStream.getTracks().forEach(t=>t.stop()); }
    if (micSourceNode) micSourceNode.disconnect();
    micStatus.textContent = 'uit';
    toggleMicBtn.textContent = 'Microfoon AAN';
    toggleMicBtn.classList.remove('secondary');
    isMicOn = false;
    musicGain.gain.value = 1.0;
  }
}

muteMicBtn.onclick = ()=>{
  if (!micStream) return;
  const tracks = micStream.getAudioTracks();
  if (!tracks.length) return;
  tracks[0].enabled = !tracks[0].enabled;
  muteMicBtn.textContent = tracks[0].enabled ? 'Mute' : 'Unmute';
}

// Ducking control
duckAmount.oninput = ()=>{ duckVal.textContent = duckAmount.value; }
function applyDucking(){
  // reduce musicGain when mic is active
  if (!isMicOn) { musicGain.gain.setValueAtTime(1.0, audioContext.currentTime); return; }
  const target = parseFloat(duckAmount.value);
  musicGain.gain.cancelScheduledValues(audioContext.currentTime);
  musicGain.gain.linearRampToValueAtTime(target, audioContext.currentTime + 0.05);
}

// Periodically monitor mic state for ducking (simple)
setInterval(()=>{ if (!audioContext) return; if (isMicOn){ applyDucking(); } else { if (musicGain) musicGain.gain.setValueAtTime(1.0, audioContext.currentTime); } }, 250);

// Master volume control
masterVol.oninput = ()=>{ if (!masterGain) initAudio(); masterGain.gain.value = parseFloat(masterVol.value); }

// Jingles
addJingleBtn.onclick = ()=> jinglePicker.click();
jinglePicker.onchange = async (e)=>{
  const f = e.target.files[0]; if (!f) return; const url = URL.createObjectURL(f); const id = 'j_'+Date.now(); jingles.push({id,name:f.name,blob:f,url}); renderJingles(); e.target.value='';
}
function renderJingles(){ jinglesList.innerHTML=''; jingles.forEach((j,i)=>{
  const d = document.createElement('div'); d.className='playlist-item'; d.innerHTML=`<div>${j.name}</div><div style='display:flex;gap:8px'><button data-i='${i}'>Play</button><button data-rem='${i}' class='secondary'>Remove</button></div>`; jinglesList.appendChild(d);
}); jinglesList.querySelectorAll('button[data-i]').forEach(b=> b.onclick = ()=> playJingle(parseInt(b.dataset.i)));
  jinglesList.querySelectorAll('button[data-rem]').forEach(b=> b.onclick = ()=> {jingles.splice(parseInt(b.dataset.rem),1); renderJingles();});
}
function playJingle(i){
  const j = jingles[i];
  const a = new Audio(j.url);
  a.crossOrigin='anonymous';
  a.play();
  // connect to audio graph
  setTimeout(()=>{ try{ const src = audioContext.createMediaElementSource(a); src.connect(musicGain); }catch(e){ } },150);
}

// Scheduler (simple local scheduler that starts playlists at given HH:MM)
addSchedBtn.onclick = ()=>{
  const time = schedTime.value.trim(); if (!time) return alert('Voer tijd in zoals 09:00');
  const playlistIdx = schedPlaylist.selectedIndex; if (playlistIdx<0) return alert('Selecteer playlist (voor nu: de full playlist)');
  scheduler.push({time, playlist: 'default'});
  renderSchedule();
};
function renderSchedule(){ schedList.innerHTML=''; scheduler.forEach((s,i)=>{ const el = document.createElement('div'); el.className='small'; el.textContent = `${s.time} — ${s.playlist}`; const b = document.createElement('button'); b.textContent='Rem'; b.className='secondary'; b.style.marginLeft='8px'; b.onclick=()=>{ scheduler.splice(i,1); renderSchedule(); }; el.appendChild(b); schedList.appendChild(el); }); }
function updateSchedOptions(){ schedPlaylist.innerHTML = '<option>Default (complete playlist)</option>'; }
updateSchedOptions();

// Scheduler runner (checks every 20s)
setInterval(()=>{
  const now = new Date(); const hh = now.getHours().toString().padStart(2,'0'); const mm = now.getMinutes().toString().padStart(2,'0'); const cur = hh+':'+mm;
  scheduler.forEach(s=>{ if (s.time===cur){ if (playlist.length>0) playIndex(0); } });
},20000);

// Recording (MediaRecorder of combined stream)
startRecordBtn.onclick = ()=>{
  initAudio();
  // combine audio destination stream and camera video (if any)
  const audioStream = destinationNode.stream;
  let finalStream = new MediaStream();
  audioStream.getAudioTracks().forEach(t=> finalStream.addTrack(t));
  if (camStream){ camStream.getVideoTracks().forEach(t=> finalStream.addTrack(t)); }
  // start MediaRecorder
  recordedChunks = [];
  recorder = new MediaRecorder(finalStream, {mimeType:'video/webm;codecs=vp8,opus'});
  recorder.ondataavailable = e=>{ if (e.data.size>0) recordedChunks.push(e.data); };
  recorder.onstop = ()=>{
    const blob = new Blob(recordedChunks, {type:'video/webm'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download = 'mijn-radio-'+Date.now()+'.webm'; a.click();
  };
  recorder.start(1000);
  startRecordBtn.disabled = true; stopRecordBtn.disabled = false;
}
stopRecordBtn.onclick = ()=>{ if (recorder && recorder.state!=='inactive') recorder.stop(); startRecordBtn.disabled=false; stopRecordBtn.disabled=true; }
stopRecordBtn.disabled=true;

// Live (very minimal WebRTC client — expects a signaling websocket and server that accepts offer and returns answer and publishes to RTMP)
startLiveBtn.onclick = async ()=>{
  const url = serverUrlInput.value.trim(); if (!url) return alert('Voer WebSocket signaling URL in, bv wss://mijnserver.example/ws');
  initAudio();
  // build local stream
  const audioStream = destinationNode.stream;
  const pc = new RTCPeerConnection();
  // add audio track
  audioStream.getAudioTracks().forEach(t=> pc.addTrack(t, audioStream));
  // add video if cam
  if (camStream) camStream.getVideoTracks().forEach(t=> pc.addTrack(t, camStream));

  // simple ICE logging
  pc.onicecandidate = e=>{ if (e.candidate && liveSocket) liveSocket.send(JSON.stringify({type:'ice',candidate:e.candidate})); };

  liveSocket = new WebSocket(url);
  liveSocket.onopen = async ()=>{
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    liveSocket.send(JSON.stringify({type:'offer',sdp:offer.sdp}));
  };
  liveSocket.onmessage = async (evt)=>{
    const msg = JSON.parse(evt.data);
    if (msg.type==='answer'){ await pc.setRemoteDescription({type:'answer',sdp:msg.sdp}); }
    if (msg.type==='ice') await pc.addIceCandidate(msg.candidate);
  };
  startLiveBtn.disabled = true; stopLiveBtn.disabled=false;
  // keep reference
  window._pc = pc;
}
stopLiveBtn.onclick = ()=>{
  if (liveSocket) liveSocket.close(); liveSocket = null; startLiveBtn.disabled=false; stopLiveBtn.disabled=true; if (window._pc){ window._pc.close(); window._pc=null; }
}
stopLiveBtn.disabled=true;

// Clear playlist
clearPlaylistBtn.onclick = ()=>{ playlist=[]; renderPlaylist(); updateSchedOptions(); }

// Save/Load from localStorage
function saveState(){ localStorage.setItem('radio_state_v1', JSON.stringify({playlist: playlist.map(p=>({name:p.name})), jingles:jingles.map(j=>({name:j.name})), scheduler})); }
function loadState(){ const s = localStorage.getItem('radio_state_v1'); if (!s) return; try{ const obj = JSON.parse(s); /* we don't recreate blobs (files) automatically */ scheduler = obj.scheduler||[]; renderSchedule(); }catch(e){} }
loadState();

// Warn on unload
window.addEventListener('beforeunload', (e)=>{ if (recorder && recorder.state==='recording') e.returnValue = 'Opname loopt nog, zeker stoppen?'; });

</script>

</body>
</html>

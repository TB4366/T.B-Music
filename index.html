<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Game Helper — UID Debug</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
<style>
  :root{--bg:#f5f7fb;--card:#fff;--primary:#0b74ff;--danger:#c0392b}
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);margin:0;padding:20px;display:flex;justify-content:center}
  .card{width:600px;background:var(--card);padding:20px;border-radius:12px;box-shadow:0 6px 24px rgba(10,10,10,0.08)}
  h1{margin:0 0 12px;font-size:20px}
  label{display:block;margin-top:12px;font-weight:600}
  input,select,button,textarea{width:100%;padding:10px;margin-top:6px;border-radius:8px;border:1px solid #d7dbe0;box-sizing:border-box;font-size:14px}
  .row{display:flex;gap:10px}
  .row button{flex:1}
  .muted{font-size:13px;color:#586069;margin-top:8px}
  .warning{background:#fff4e5;border:1px solid #ffd8a8;padding:10px;border-radius:8px;margin-top:10px}
  .danger{color:var(--danger);font-weight:700;margin-top:8px}
  .detected-list{margin-top:10px}
  .detected-item{padding:8px;border:1px dashed #d7dbe0;border-radius:8px;margin-top:8px;display:flex;justify-content:space-between;align-items:center}
  .small{font-size:12px;color:#6b7280}
  .debug{white-space:pre-wrap;background:#0f1724;color:#e6eef8;padding:10px;border-radius:8px;margin-top:10px;font-family:monospace;font-size:13px}
</style>
</head>
<body>
  <div class="card">
    <h1>Game Helper — UID detectie & debug</h1>

    <label for="uid">Console ID / Skin Key (UID)</label>
    <input id="uid" placeholder="Plak je UID hier (of hele gekopieerde string)">
    <div class="muted">Je kunt zowel de raw UID plakken (bv. <code>66464ffd-a57c-496c-b60f-79ecc0d82a4a</code>) als een langere gekopieerde string.</div>

    <label style="margin-top:12px;"><input type="checkbox" id="hideKey" checked> <span class="small">Verberg invoer (password)</span></label>

    <div style="display:flex;gap:8px;margin-top:12px;">
      <button id="scanBtn" style="flex:1;">Scan UID</button>
      <button id="verifyBtn" style="flex:1;">Check & Koppel UID</button>
    </div>

    <div id="detected" class="detected-list" style="display:none;"></div>

    <label style="margin-top:12px;">
      <input type="checkbox" id="confirmRaw"> <strong>Ik bevestig dat dit mijn eigen Agar.io UID is (gebruik raw UID)</strong>
    </label>

    <div class="warning" id="explain">
      Standaard wordt alleen een <strong>SHA‑256 hash</strong> van je UID gestuurd. Wanneer je raw UID toestaat, wordt deze tijdelijk gebruikt en daarna meteen uit het invoerveld verwijderd. Raw UID wordt niet in localStorage bewaard.
    </div>

    <label for="region">Bot regio</label>
    <select id="region"><option>ME South 1</option><option>EU West</option><option>US East</option></select>

    <label for="mode">Modus</label>
    <select id="mode"><option>Burst</option><option>Classic</option></select>

    <label for="botName">Bot naam</label>
    <input id="botName" placeholder="bijv. T.B">

    <label for="party">Party link</label>
    <input id="party" placeholder="https://r.agar.io/?party=...">

    <div style="display:flex;gap:8px;margin-top:12px;">
      <button id="startBotBtn" style="flex:1;">Start Bot</button>
      <button id="showPayloadBtn" style="flex:1;background:#eef2ff;border:1px solid #c7ddff;color:#0b74ff">Toon payload</button>
    </div>

    <div id="status" class="muted" style="margin-top:12px"></div>
    <div id="error" class="danger" style="display:none"></div>

    <div id="debugBox" style="display:none" class="debug"></div>
  </div>

<script>
/*
  Verbeterde detectie en fallback:
  - detecteert UUID-achtige substrings (v4-like)
  - toont alle gevonden matches en laat de gebruiker kiezen
  - wanneer gebruiker confirmRaw checked, stuurt het verzoek ook raw UID als 'uidRaw' en 'uid'
  - stuurt altijd 'uidHash' (sha256 hex)
  - wist raw input direct na verzending
  - toont debug payload op verzoek
*/

const uidInput = document.getElementById('uid');
const hideKey = document.getElementById('hideKey');
const scanBtn = document.getElementById('scanBtn');
const detectedBox = document.getElementById('detected');
const verifyBtn = document.getElementById('verifyBtn');
const startBotBtn = document.getElementById('startBotBtn');
const status = document.getElementById('status');
const errorBox = document.getElementById('error');
const confirmRaw = document.getElementById('confirmRaw');
const showPayloadBtn = document.getElementById('showPayloadBtn');
const debugBox = document.getElementById('debugBox');

hideKey.addEventListener('change', () => {
  uidInput.type = hideKey.checked ? 'password' : 'text';
});
uidInput.type = hideKey.checked ? 'password' : 'text';

// UUID regex (typical 8-4-4-4-12 hex groups)
function findUUIDs(text){
  if(!text) return [];
  const regex = /[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/g;
  const arr = [];
  let m;
  while((m = regex.exec(text)) !== null){
    arr.push(m[0]);
    // avoid infinite loops with zero-length matches (not applicable here)
  }
  return arr;
}

// fallback: if no UUID found but string length matches 36, assume it's a UUID-like without hyphens
function fallbackExtract(text){
  if(!text) return null;
  const candidate = text.trim();
  if(candidate.length === 36 && candidate.includes('-')) return candidate;
  // if length 32 with only hex, insert hyphens
  const onlyHex = /^[0-9a-fA-F]{32}$/.test(candidate);
  if(onlyHex){
    return candidate.slice(0,8)+'-'+candidate.slice(8,12)+'-'+candidate.slice(12,16)+'-'+candidate.slice(16,20)+'-'+candidate.slice(20);
  }
  return null;
}

scanBtn.addEventListener('click', () => {
  errorBox.style.display='none';
  status.textContent = 'Scannen...';
  const raw = uidInput.value || '';
  const found = findUUIDs(raw);
  const list = [];
  if(found.length) list.push(...found);
  else {
    const fb = fallbackExtract(raw);
    if(fb) list.push(fb);
  }
  renderDetected(list);
});

function renderDetected(list){
  detectedBox.innerHTML = '';
  if(!list.length){
    detectedBox.style.display='none';
    status.textContent = 'Geen duidelijke UID-achtige string gevonden. Je kunt toch proberen op "Check & Koppel UID".';
    return;
  }
  detectedBox.style.display='block';
  status.textContent = `Gevonden ${list.length} UID(s). Kies welke je wilt gebruiken.`;
  list.forEach((u, idx) => {
    const div = document.createElement('div');
    div.className = 'detected-item';
    const left = document.createElement('div');
    left.innerHTML = `<div style="font-weight:600">Gevonden UID ${idx+1}</div><div class="small">${u}</div>`;
    const right = document.createElement('div');
    const btn = document.createElement('button');
    btn.textContent = 'Gebruik';
    btn.style.padding='6px 10px';
    btn.onclick = () => {
      // set the input to the chosen uid (unmasked while user decides)
      uidInput.type = 'text';
      uidInput.value = u;
      hideKey.checked = false;
      status.textContent = 'UID geselecteerd voor gebruik.';
    };
    right.appendChild(btn);
    div.appendChild(left);
    div.appendChild(right);
    detectedBox.appendChild(div);
  });
}

// web crypto helper sha256 hex
async function sha256Hex(msg){
  const enc = new TextEncoder();
  const data = enc.encode(msg);
  const hash = await crypto.subtle.digest('SHA-256', data);
  const bytes = Array.from(new Uint8Array(hash));
  return bytes.map(b=>b.toString(16).padStart(2,'0')).join('');
}

// POST helper
async function postJSON(url, data){
  const resp = await fetch(url, {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(data)
  });
  // try to parse json but handle non-json errors
  let body = null;
  try { body = await resp.json(); } catch(e){ body = null; }
  return { ok: resp.ok, status: resp.status, body };
}

verifyBtn.addEventListener('click', async () => {
  clearMessages();
  const rawInput = uidInput.value.trim();
  if(!rawInput){
    showError('Voer eerst een UID in.');
    return;
  }
  status.textContent = 'Verwerken...';
  // try to detect normalized UID
  let uidToUse = null;
  const found = findUUIDs(rawInput);
  if(found.length) uidToUse = found[0];
  else {
    const fb = fallbackExtract(rawInput);
    if(fb) uidToUse = fb;
  }
  // if still null, use rawInput as-is (user might have server expecting different format)
  if(!uidToUse) uidToUse = rawInput;

  try {
    const uidHash = await sha256Hex(uidToUse);

    // prepare payload — we include multiple keys so backend compatibility increases
    const payload = { uidHash, uid: uidToUse };
    // include raw only if user confirmed
    if(confirmRaw.checked){
      payload.uidRaw = uidToUse;
    }

    // show masked debug briefly in UI and console
    debugBox.style.display='none';
    console.log('Versturen naar /api/verify-uid ->', payload);

    const resp = await postJSON('/api/verify-uid', payload);
    if(resp.ok && resp.body && resp.body.ok){
      // store only id + hash
      const store = { id: resp.body.user.id, uidHash };
      localStorage.setItem('linkedUser', JSON.stringify(store));
      status.textContent = '✅ UID gekoppeld! User ID: ' + resp.body.user.id;
    } else {
      showError('Server gaf een fout: ' + ((resp.body && resp.body.message) || ('HTTP '+resp.status)));
    }
  } catch(e){
    console.error(e);
    showError('Fout tijdens verwerken: ' + e.message);
  } finally {
    // clear raw input from UI if raw was used for safety (we still cleared above only if confirmRaw)
    if(confirmRaw.checked) {
      uidInput.value = '';
      hideKey.checked = true;
      uidInput.type = 'password';
    }
  }
});

startBotBtn.addEventListener('click', async () => {
  clearMessages();
  const linked = JSON.parse(localStorage.getItem('linkedUser') || 'null');
  if(!linked){
    showError('UID niet gekoppeld. Gebruik "Check & Koppel UID".');
    return;
  }
  status.textContent = 'Starten...';
  // assemble payload; allow sending raw if present in input and user confirmed
  let uidCandidate = null;
  const rawInput = uidInput.value.trim();
  const found = findUUIDs(rawInput);
  if(found.length) uidCandidate = found[0];
  else {
    const fb = fallbackExtract(rawInput);
    if(fb) uidCandidate = fb;
  }
  // if user confirmed and there's a candidate, include raw in payload (and compute hash)
  let payload = {
    userId: linked.id,
    uidHash: linked.uidHash || null,
    botName: document.getElementById('botName').value.trim(),
    region: document.getElementById('region').value,
    mode: document.getElementById('mode').value,
    party: document.getElementById('party').value.trim()
  };

  if(confirmRaw.checked && uidCandidate){
    payload.uidRaw = uidCandidate;
    payload.uid = uidCandidate;
    payload.uidHash = await sha256Hex(uidCandidate);
  } else {
    // send uid field too for compatibility (use stored hash -> no raw)
    if(linked.uidHash) payload.uidHash = linked.uidHash;
  }

  console.log('Versturen /api/start-bot ->', payload);
  if(debugBox.style.display==='block') debugBox.textContent = JSON.stringify(payload, null, 2);

  try {
    const resp = await postJSON('/api/start-bot', payload);
    if(resp.ok && resp.body && resp.body.ok){
      status.textContent = '✅ Bot gestart! Session ID: ' + (resp.body.sessionId || '(geen id terug)');
    } else {
      showError('Start mislukt: ' + ((resp.body && resp.body.message) || ('HTTP '+resp.status)));
    }
  } catch(e){
    console.error(e);
    showError('Netwerkfout: ' + e.message);
  } finally {
    // clear raw input if we used it
    if(confirmRaw.checked && uidCandidate){
      uidInput.value = '';
      hideKey.checked = true;
      uidInput.type = 'password';
    }
  }
});

showPayloadBtn.addEventListener('click', () => {
  if(debugBox.style.display === 'none'){
    debugBox.style.display = 'block';
    debugBox.textContent = 'Payload zal verschijnen in de console (devtools) bij acties. Klik "Check & Koppel UID" of "Start Bot" om payload te zien.';
  } else {
    debugBox.style.display = 'none';
  }
});

// helper messages
function showError(msg){
  errorBox.style.display='block';
  errorBox.textContent = msg;
  status.textContent = '';
}
function clearMessages(){
  errorBox.style.display='none';
  errorBox.textContent = '';
  status.textContent = '';
}

// on load: attempt to pre-scan any pasted content
window.addEventListener('paste', (e)=>{
  // small convenience: auto-scan on paste
  setTimeout(()=> {
    const raw = uidInput.value || '';
    const found = findUUIDs(raw);
    if(found.length) renderDetected(found);
  }, 50);
});
</script>
</body>
</html>
